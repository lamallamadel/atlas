services:
  postgres:
    image: postgres:16-alpine
    container_name: postgres_db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-atlas}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-atlas}
      POSTGRES_DB: ${POSTGRES_DB:-atlas}
    ports:
      - target: 5432
        published: "${POSTGRES_PORT:-5432}"
        protocol: tcp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-atlas} -d ${POSTGRES_DB:-atlas}" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: backend_app
    restart: unless-stopped
    ports:
      - target: 8080
        published: "${BACKEND_PORT:-8080}"
        protocol: tcp
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      # Forcer le backend à utiliser la configuration Postgres (application-prod.yml)
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE:-prod}

      # Datasource prod paramétrable
      DB_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB:-atlas}
      DB_USERNAME: ${POSTGRES_USER:-atlas}
      DB_PASSWORD: ${POSTGRES_PASSWORD:-atlas}

      # Optionnel si tu utilises cors.allowed-origins
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-http://localhost:4200}

    healthcheck:
      test: [ "CMD-SHELL", "curl -fsS http://localhost:8080/actuator/health | grep -q '\"status\":\"UP\"'" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

volumes:
  postgres_data:
    name: postgres_data
